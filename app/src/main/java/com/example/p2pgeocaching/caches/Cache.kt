package com.example.p2pgeocaching.caches

import com.example.p2pgeocaching.p2pexceptions.CacheDataTypeNotDefinedException
import com.example.p2pgeocaching.p2pexceptions.IllegalCacheTypeException
import com.example.p2pgeocaching.p2pexceptions.ParametersAreNullException
import java.security.PrivateKey
import java.security.PublicKey
import javax.crypto.Cipher

const val OWN_CACHE = "OwnCache"
const val UNSOLVED_CACHE = "UnsolvedCache"
const val SOLVED_CACHE = "SolvedCache"

// TODO: cache should update with bluetooth connection transfer
/**
 * This class saves all the data related to a cache.
 * Cache class can be called in two ways, either to create a new cache or to save an existing one.
 * The title of the cache is saved in [title], its description in [desc], neither may contain an
 * illegal character.
 * [creator] contains the name of the cache's creator, also no illegal characters allowed.
 * The unique identifier [id] is generated by concatenating [title], ';', [desc], then hashing them.
 * The public key is saved in [pubKey], the private key  in [prvKey].
 * The [hallOfFame] contains the encrypted name of the people that have completed the cache.
 * It saves them as an array of ByteArrays.
 * The only item contained at initialization is the [creator].
 * To decrypt, the [pubKey] is used.
 * For encrypting, you need the [prvKey], which you receive upon finding the physical cache.
 */
open class Cache(
    protected val title: String,
    protected val desc: String,
    protected val creator: String,
    protected var id: Int,
    protected var pubKey: PublicKey?,
    protected var prvKey: PrivateKey?,
    protected var hallOfFame: MutableSet<ByteArray>?
) {
    protected var plainTextHOF: String = ""


    /**
     * Here we only have to initialize plainTextHOF
     */
    init {
        updatePlainTextHOF()
    }


    /**
     * This function takes an ByteArray containing a cipher text [byteCipher] as input
     * It returns the plain text as a String.
     * This decryption is done using the public key.
     */
    private fun decryptToString(byteCipher: ByteArray): String {
        // Setting up the object to decrypt
        val cipher = Cipher.getInstance("RSA")
        cipher.init(Cipher.DECRYPT_MODE, pubKey)

        // Here we actually decrypt the message and return it as a String
        val bytePlain = cipher.doFinal(byteCipher)
        return bytePlain.toString()
    }


    /**
     * This function decrypts the [hallOfFame] and returns it as a String.
     * Each entry of [hallOfFame] is separated by a ";" in the final String.
     * If [hallOfFame] is null, an empty string is returned.
     */
    fun hallToString(): String {
        var hofString = ""
        return if (hallOfFame == null) {
            ""
        } else {
            for (cipherEntry in hallOfFame!!) {
                hofString += decryptToString(cipherEntry) + ";"
            }
            hofString
        }
    }


    /**
     * A simple function which updates the [plainTextHOF] parameter with the current [hallOfFame].
     */
    protected fun updatePlainTextHOF() {
        plainTextHOF = hallToString()
    }


    /**
     * This function is used to add any number of people to the list
     */
    fun addPeopleToHOF(people: Set<ByteArray>) {
        // Add the people to HOF
        if (hallOfFame == null) {
            hallOfFame = people.toMutableSet()
        } else {
            for (person in people) {
                hallOfFame!!.add(person)
            }
        }
        updatePlainTextHOF()
    }


    /**
     * Simple function that calls the addPeopleToHOF() function, with its input cast to a set.
     */
    fun addPersonToHOF(person: ByteArray) {
        addPeopleToHOF(setOf(person))

    }


    /**
     * The toString() function now concatenates most things in human readable format.
     * Format is as follows: "<name>: <data>;", repeated.
     */
    override fun toString(): String {
        return "Title: $title; Description: $desc; Creator: $creator; ID: $id; " +
                "Public Key: ${pubKey.toString()}; Private key: ${prvKey.toString()}; " +
                "Hall of Fame: ${hallOfFame.toString()};"
    }


    /**
     * This is used to create a [Cache] from a [CacheData] object.
     * [data] is the object to be read from.
     */
    fun dataToCache(data: CacheData): Cache {
        return when (data.type) {
            OWN_CACHE -> dataToOwnCache(data)
            SOLVED_CACHE -> dataToSolvedCache(data)
            UNSOLVED_CACHE -> dataToUnsolvedCache(data)
            else -> throw CacheDataTypeNotDefinedException()
        }
    }


    /**
     * Simple function that makes a [OwnCache] from a [CacheData] object [data].
     */
    private fun dataToOwnCache(data: CacheData): Cache {
        return OwnCache(data.title, data.desc, data.creator)
    }


    /**
     * Simple function that makes a [SolvedCache] from a [CacheData] object [data].
     */
    private fun dataToSolvedCache(data: CacheData): Cache {
        if (data.pubKey != null && data.prvKey != null && data.hallOfFame != null) {
            return SolvedCache(
                data.title,
                data.desc,
                data.creator,
                data.id,
                data.pubKey!!,
                data.prvKey!!,
                data.hallOfFame!!
            )
        } else {
            throw ParametersAreNullException()
        }
    }


    /**
     * Simple function that makes a [UnsolvedCache] from a [CacheData] object [data].
     */
    private fun dataToUnsolvedCache(data: CacheData): Cache {
        if (data.pubKey != null && data.hallOfFame != null) {
            return UnsolvedCache(
                data.title,
                data.desc,
                data.creator,
                data.id,
                data.pubKey!!,
                data.hallOfFame!!
            )
        } else {
            throw ParametersAreNullException()
        }
    }

    /**
     * This function takes a [Cache] [cache] and transforms it into a [CacheData] object.
     */
    fun cacheToData(cache: Cache): CacheData {
        return when (cache) {
            is OwnCache -> CacheData(
                cache.title,
                cache.desc,
                cache.creator,
                cache.id,
                cache.pubKey,
                cache.prvKey,
                cache.hallOfFame,
                OWN_CACHE
            )
            is UnsolvedCache -> CacheData(
                cache.title,
                cache.desc,
                cache.creator,
                cache.id,
                cache.pubKey,
                null,
                cache.hallOfFame,
                UNSOLVED_CACHE
            )
            is SolvedCache -> CacheData(
                cache.title,
                cache.desc,
                cache.creator,
                cache.id,
                cache.pubKey,
                cache.prvKey,
                cache.hallOfFame,
                SOLVED_CACHE
            )
            else -> throw IllegalCacheTypeException()
        }
    }


}