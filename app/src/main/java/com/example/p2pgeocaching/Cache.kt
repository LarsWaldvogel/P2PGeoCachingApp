package com.example.p2pgeocaching

import android.security.keystore.KeyProperties
import java.security.*
import java.util.Objects.hash
import javax.crypto.Cipher

/**
 * This class saves all the data related to a cache.
 * Cache class can be called in two ways, either to create a new cache or to save an existing one.
 * The title of the cache is saved in [title], its description in [desc], neither may contain a ";".
 * [creator] contains the name of the cache's creator.
 * The unique identifier [id] is generated by concatenating [title], ";", [desc], then hashing them.
 * The public key is saved in [pubKey], the private key  in [prvKey].
 * The [hallOfFame] contains the encrypted name of the people that have completed the cache.
 * It saves them as an array of ByteArrays.
 * The only item contained at initialization is the [creator].
 * To decrypt, the [pubKey] is used.
 * For encrypting, you need the [prvKey], which you receive upon finding the physical cache.
 */
class Cache(
    private val title: String,
    private val desc: String,
    private val creator: String,
    private var id: Int,
    private var pubKey: PublicKey?,
    private var prvKey: PrivateKey?,
    private var hallOfFame: Array<ByteArray>?
) {
    // TODO add exception when text contains ";"
    /**
     * Constructor for creating a new cache
     * Here, we only give it
     */
    constructor(title: String, desc: String, creator: String) : this(
        title,
        desc,
        creator,
        -1,
        null,
        null,
        null
    ) {
        // Here we fabricate the string we want to hash by concatenating [title], ";" and [desc]
        val stringToHash = "$title;$desc"

        // The hash is saved to [id], which serves as the unique identifier of the cache
        id = hash(stringToHash)

        // The key pair is created and saved to [pubKey] and [prvKey]
        val keyPair: KeyPair = generateKeyPair()
        pubKey = keyPair.public
        prvKey = keyPair.private

        // Here we encrypt [creator] and add it to [hallOfFame]
        val cipher = Cipher.getInstance("RSA")
        cipher.init(Cipher.ENCRYPT_MODE, prvKey)
        val encryptedCreator: ByteArray = cipher.doFinal(creator.toByteArray())
        hallOfFame = arrayOf(encryptedCreator)
    }

    // TODO throw exception when [creator] and first entry of [hallOfFame] do not match
    // TODO add exception when text contains ";"
    /**
     * Constructor for saving existing cache
     * This assumes, all information of the cache is known, except for the [prvKey]
     */
    constructor(
        title: String,
        desc: String,
        creator: String,
        id: Int,
        pubKey: PublicKey,
        hallOfFame: Array<ByteArray>?
    ) : this(title, desc, creator, id, pubKey, null, hallOfFame)

    /**
     * This function generates a RSA key pair, which it returns.
     * The key is not generated with the [id] as initializer, because that could be replicated.
     */
    private fun generateKeyPair(): KeyPair {
        // This creates an object capable of
        val generator = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA)

        // The generator is initialized with a key length of 2048 bit and a random number
        generator.initialize(2048, SecureRandom())

        // key pair is created and returned
        return generator.genKeyPair()

    }

    /**
     * This function takes an ByteArray containing a cipher text [byteCipher] as input
     * It returns the plain text as a String.
     * This decryption is done using the public key.
     */
    private fun decryptToString(byteCipher: ByteArray): String {
        // Setting up the object to decrypt
        val cipher = Cipher.getInstance("RSA")
        cipher.init(Cipher.DECRYPT_MODE, pubKey)

        // Here we actually decrypt the message and return it as a String
        val bytePlain = cipher.doFinal(byteCipher)
        return bytePlain.toString()
    }

    /**
     * This function decrypts the [hallOfFame] and returns it as a String.
     * Each entry of [hallOfFame] is separated by a "\n" in the final String.
     * If [hallOfFame] is null, an empty string is returned.
     */
    fun hallToString(): String {
        var hofString = ""
        return if (hallOfFame == null) {
            ""
        } else {
            for (cipherEntry in hallOfFame!!) {
                hofString += decryptToString(cipherEntry) + "\n"
            }
            hofString
        }
    }

    // TODO add exception when [newPrvKey] and [pubKey] do not match
    /**
     * This function takes the name of the [finder] and the [newPrvKey] that was found at the cache.
     * It checks if the [newPrvKey] is correct, then adds it to the cache
     * With the [prvKey], it adds the [finder] to the [hallOfFame]
     */

    fun foundCache(finder: String, newPrvKey: PrivateKey): Boolean {
        // TODO if [pubKey] matches [prvKey]... else throw exception
        prvKey = newPrvKey
        // TODO add name to [hallOfFame]

    }


}