package com.example.p2pgeocaching

import android.security.keystore.KeyProperties
import java.security.*
import java.util.Objects.hash
import javax.crypto.Cipher

/**
 * This class saves all the data related to a cache.
 * This constructor is used to generate a new cache.
 * The title of the cache is saved in [title], its description in [desc], neither may contain a ";".
 * [creator] contains the name of the cache's creator.
 * The unique identifier [id] is generated by concatenating [title], ";", [desc], then hashing them.
 * The public key is saved in [pubKey], the private key  in [prvKey].
 * The [hallOfFame] contains the encrypted name of the people that have completed the cache.
 * It saves them as an array of ByteArrays.
 * The only item contained at initialization is the [creator].
 * To decrypt, the [pubKey] is used.
 * For encrypting, you need the [prvKey], which you receive upon finding the physical cache.
 */
class Cache constructor(private val title: String,
                        private val desc: String,
                        private val creator: String) {
    private val id: Int
    private val pubKey: PublicKey
    private val prvKey: PrivateKey
    private var hallOfFame: Array<ByteArray>

    init {
        // Here we fabricate the string we want to hash by concatenating [title], ";" and [desc]
        val stringToHash = "$title;$desc"

        // The hash is saved to [id], which serves as the unique identifier of the cache
        id = hash(stringToHash)

        // The key pair is created and saved to [pubKey] and [prvKey]
        val keyPair: KeyPair = generateKeyPair()
        pubKey = keyPair.public
        prvKey = keyPair.private

        // Here we encrypt [creator] and add it to [hallOfFame]
        val cipher = Cipher.getInstance("RSA")
        cipher.init(Cipher.ENCRYPT_MODE, prvKey)
        val encryptedCreator: ByteArray = cipher.doFinal(creator.toByteArray())
        hallOfFame = arrayOf(encryptedCreator)

    }

    /**
     * This function generates a RSA key pair, which it returns.
     * The key is not generated with the [id] as initializer, because that could be replicated.
     */
    private fun generateKeyPair(): KeyPair {
        // This creates an object capable of
        val generator = KeyPairGenerator.getInstance(KeyProperties.KEY_ALGORITHM_RSA)

        // The generator is initialized with a key length of 2048 bit and a random number
        generator.initialize(2048, SecureRandom())

        // key pair is created and returned
        return generator.genKeyPair()

    }

    /**
     * This function takes an ByteArray containing a cipher text [byteCipher] as input
     * It returns the plain text as a String.
     * This decryption is done using the public key.
     */
    private fun decryptToString(byteCipher: ByteArray): String {
        // Setting up the object to decrypt
        val cipher = Cipher.getInstance("RSA")
        cipher.init(Cipher.DECRYPT_MODE, pubKey)

        // Here we actually decrypt the message and return it as a String
        val bytePlain = cipher.doFinal(byteCipher)
        return bytePlain.toString()
    }

    /**
     * This function decrypts the [hallOfFame] and returns it as a String.
     * Each entry of [hallOfFame] is separated by a "\n" in the final String.
     */
    fun hallToString(): String {
        var hofString = ""
        for (cipherEntry in hallOfFame) {
            hofString += decryptToString(cipherEntry) + "\n"
        }
        return hofString
    }


}